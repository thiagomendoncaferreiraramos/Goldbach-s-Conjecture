%% TCCs associated with theory gcd_rem
%% This file was automatically generated by PVS, please **do not modify** by hand.
gcd_rem_TCCS: THEORY BEGIN

	% Subtype TCC generated (at line 13, column 25) for  M + N
	% expected type  nat
	  % proved
	gcd_rem_TCC1: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	    M = abs(m) AND N = abs(n) AND (M = 0 OR N = 0) IMPLIES
	     rational_pred(M + N) AND integer_pred(M + N) AND M + N >= 0
	
	% Subtype TCC generated (at line 14, column 28) for  N
	% expected type  int
	  % proved
	gcd_rem_TCC2: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND (M >= N)
	     IMPLIES rational_pred(N) AND integer_pred(N)
	
	% Subtype TCC generated (at line 14, column 36) for  M
	% expected type  nat
	  % proved
	gcd_rem_TCC3: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND (M >= N)
	     IMPLIES rational_pred(M) AND integer_pred(M) AND M >= 0
	
	% Subtype TCC generated (at line 14, column 38) for  N
	% expected type  posnat
	  % proved
	gcd_rem_TCC4: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND (M >= N)
	     IMPLIES rational_pred(N) AND integer_pred(N) AND N >= 0 AND N > 0
	
	% Subtype TCC generated (at line 14, column 31) for  nmod(M, N)
	% expected type  {n: int | NOT abs(N) + abs(n) = 0}
	  % proved
	gcd_rem_TCC5: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND (M >= N)
	     IMPLIES NOT abs(N) + abs(nmod(M, N)) = 0
	
	% Termination TCC generated (at line 14, column 20) for
	% gcd_rem(N, nmod(M, N))
	  % proved
	gcd_rem_TCC6: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND (M >= N)
	     IMPLIES abs(N) + abs(nmod(M, N)) < abs(m) + abs(n)
	
	% Subtype TCC generated (at line 15, column 15) for  M
	% expected type  int
	  % proved
	gcd_rem_TCC7: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND NOT M >= N
	     IMPLIES rational_pred(M) AND integer_pred(M)
	
	% Subtype TCC generated (at line 15, column 23) for  N
	% expected type  nat
	  % proved
	gcd_rem_TCC8: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND NOT M >= N
	     IMPLIES rational_pred(N) AND integer_pred(N) AND N >= 0
	
	% Subtype TCC generated (at line 15, column 25) for  M
	% expected type  posnat
	  % proved
	gcd_rem_TCC9: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND NOT M >= N
	     IMPLIES rational_pred(M) AND integer_pred(M) AND M >= 0 AND M > 0
	
	% Subtype TCC generated (at line 15, column 18) for  nmod(N, M)
	% expected type  {n: int | NOT abs(M) + abs(n) = 0}
	  % proved
	gcd_rem_TCC10: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND NOT M >= N
	     IMPLIES NOT abs(M) + abs(nmod(N, M)) = 0
	
	% Termination TCC generated (at line 15, column 7) for
	% gcd_rem(M, nmod(N, M))
	  % proved
	gcd_rem_TCC11: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0,
	          M: {n: nonneg_real | n >= m AND n >= -m},
	          N: {n_1: nonneg_real | n_1 >= n AND n_1 >= -n}):
	         (M = abs(m)) AND (N = abs(n)) AND (NOT M = 0) AND (NOT N = 0)
	     AND NOT M >= N
	     IMPLIES abs(M) + abs(nmod(N, M)) < abs(m) + abs(n)
	
	% Subtype TCC generated (at line 22, column 12) for  n
	% expected type  {n: int | NOT abs(m) + abs(n) = 0}
	  % proved
	gcd_rem_commutes_TCC1: OBLIGATION
	FORALL (m: int, n: int | abs(m) + abs(n) /= 0): NOT abs(m) + abs(n) = 0
	
	% The subtype TCC (at line 22, column 27) in decl nil for
	% term generated from gcd_rem_commutes  m
	% expected type  {n_1: int | NOT abs(n_1) + abs(n) = 0}
	% The subtype TCC (at line 27, column 20) in decl nil for
	% term generated from gcd_rem_divides_left  n
	% expected type  {n: int | NOT abs(m) + abs(n) = 0}
	% The subtype TCC (at line 32, column 20) in decl nil for
	% term generated from gcd_rem_divides_right  n
	% expected type  {n: int | NOT abs(m) + abs(n) = 0}
	% The subtype TCC (at line 38, column 12) in decl nil for
	% term generated from gcd_rem_greater  n
	% expected type  {n: int | NOT abs(m) + abs(n) = 0}
	% Subtype TCC generated (at line 41, column 38) for  n
	% expected type  {n: int | NOT abs(m) + abs(n) = 0}
	  % proved
	linear_comb_TCC1: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n): NOT abs(m) + abs(n) = 0
	
	% The subtype TCC (at line 22, column 27) in decl nil for
	 % term generated from gcd_rem_commutes  m
	    % expected type  {n_1: int | NOT abs(n_1) + abs(n) = 0}
	  % is subsumed by gcd_rem_commutes_TCC1
	% The subtype TCC (at line 27, column 20) in decl nil for
	 % term generated from gcd_rem_divides_left  n
	    % expected type  {n: int | NOT abs(m) + abs(n) = 0}
	  % is subsumed by gcd_rem_commutes_TCC1
	% The subtype TCC (at line 32, column 20) in decl nil for
	 % term generated from gcd_rem_divides_right  n
	    % expected type  {n: int | NOT abs(m) + abs(n) = 0}
	  % is subsumed by gcd_rem_commutes_TCC1
	% The subtype TCC (at line 38, column 12) in decl nil for
	 % term generated from gcd_rem_greater  n
	    % expected type  {n: int | NOT abs(m) + abs(n) = 0}
	  % is subsumed by gcd_rem_commutes_TCC1
	
	% Subtype TCC generated (at line 42, column 27) for  div(m, n) - 1
	% expected type  nat
	  % proved
	linear_comb_TCC2: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    nmod(m, n) = 0 IMPLIES div(m, n) - 1 >= 0
	
	% Subtype TCC generated (at line 42, column 24) for  (1, div(m, n) - 1)
	% expected type  {ret: [nat, nat] |
	%    gcd_rem(m, n) = ret`1 * m - ret`2 * n}
	  % proved
	linear_comb_TCC3: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    nmod(m, n) = 0 IMPLIES gcd_rem(m, n) = 1 * m - (div(m, n) - 1) * n
	
	% Subtype TCC generated (at line 43, column 28) for  n - div(n, m) + 1
	% expected type  nat
	  % proved
	linear_comb_TCC4: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    NOT nmod(m, n) = 0 AND nmod(n, m) = 0 IMPLIES n - div(n, m) + 1 >= 0
	
	% Subtype TCC generated (at line 43, column 41) for  m - 1
	% expected type  nat
	  % proved
	linear_comb_TCC5: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    NOT nmod(m, n) = 0 AND nmod(n, m) = 0 IMPLIES m - 1 >= 0
	
	% Subtype TCC generated (at line 43, column 27) for
	% (n - div(n, m) + 1, m - 1)
	% expected type  {ret: [nat, nat] |
	%    gcd_rem(m, n) = ret`1 * m - ret`2 * n}
	  % proved
	linear_comb_TCC6: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    NOT nmod(m, n) = 0 AND nmod(n, m) = 0 IMPLIES
	     gcd_rem(m, n) = (n - div(n, m) + 1) * m - (m - 1) * n
	
	% Subtype TCC generated (at line 45, column 40) for  nmod(m, n)
	% expected type  posnat
	  % proved
	linear_comb_TCC7: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n,
	          v:
	            [d1: {z: [m: posnat, {n: posnat | m /= n}] | z`1 + z`2 < m + n} ->
	               {ret: [nat, nat] |
	                  gcd_rem(d1`1, d1`2) = ret`1 * d1`1 - ret`2 * d1`2}]):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND m > n IMPLIES
	     FORALL (k1: nat): k1 = v(nmod(m, n), n)`1 IMPLIES nmod(m, n) > 0
	
	% Subtype TCC generated (at line 45, column 50) for  n
	% expected type  {n_1: posnat | nmod(m, n) /= n_1}
	  % proved
	linear_comb_TCC8: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n,
	          v:
	            [d1: {z: [m: posnat, {n: posnat | m /= n}] | z`1 + z`2 < m + n} ->
	               {ret: [nat, nat] |
	                  gcd_rem(d1`1, d1`2) = ret`1 * d1`1 - ret`2 * d1`2}]):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND m > n IMPLIES
	     FORALL (k1: nat): k1 = v(nmod(m, n), n)`1 IMPLIES nmod(m, n) /= n
	
	% Termination TCC generated (at line 45, column 28) for
	% linear_comb(nmod(m, n), n)
	  % proved
	linear_comb_TCC9: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n,
	          v:
	            [d1: {z: [m: posnat, {n: posnat | m /= n}] | z`1 + z`2 < m + n} ->
	               {ret: [nat, nat] |
	                  gcd_rem(d1`1, d1`2) = ret`1 * d1`1 - ret`2 * d1`2}]):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND m > n IMPLIES
	     FORALL (k1: nat): k1 = v(nmod(m, n), n)`1 IMPLIES nmod(m, n) + n < m + n
	
	% Subtype TCC generated (at line 46, column 14) for
	% (k1, k2 + div(m, n) * k1)
	% expected type  {ret: [nat, nat] |
	%    gcd_rem(m, n) = ret`1 * m - ret`2 * n}
	  % proved
	linear_comb_TCC10: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n,
	          v:
	            [d1: {z: [m: posnat, {n: posnat | m /= n}] | z`1 + z`2 < m + n} ->
	               {ret: [nat, nat] |
	                  gcd_rem(d1`1, d1`2) = ret`1 * d1`1 - ret`2 * d1`2}]):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND m > n IMPLIES
	     FORALL (k1: nat, k2: nat):
	       k1 = v(nmod(m, n), n)`1 AND k2 = v(nmod(m, n), n)`2 IMPLIES
	        gcd_rem(m, n) = k1 * m - (k2 + div(m, n) * k1) * n
	
	% Subtype TCC generated (at line 44, column 39) for  nmod(m, n)
	% expected type  posnat
	  % proved
	linear_comb_TCC11: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND m > n IMPLIES nmod(m, n) > 0
	
	% Subtype TCC generated (at line 44, column 49) for  n
	% expected type  {n_1: posnat | nmod(m, n) /= n_1}
	  % proved
	linear_comb_TCC12: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND m > n IMPLIES nmod(m, n) /= n
	
	% Termination TCC generated (at line 44, column 27) for
	% linear_comb(nmod(m, n), n)
	  % proved
	linear_comb_TCC13: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND m > n IMPLIES
	     nmod(m, n) + n < m + n
	
	% Subtype TCC generated (at line 48, column 30) for  nmod(n, m)
	% expected type  {n: posnat | m /= n}
	  % proved
	linear_comb_TCC14: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n,
	          v:
	            [d1: {z: [m: posnat, {n: posnat | m /= n}] | z`1 + z`2 < m + n} ->
	               {ret: [nat, nat] |
	                  gcd_rem(d1`1, d1`2) = ret`1 * d1`1 - ret`2 * d1`2}]):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND NOT m > n IMPLIES
	     FORALL (k1: nat):
	       k1 = v(m, nmod(n, m))`1 IMPLIES nmod(n, m) > 0 AND m /= nmod(n, m)
	
	% Termination TCC generated (at line 48, column 16) for
	% linear_comb(m, nmod(n, m))
	  % proved
	linear_comb_TCC15: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n,
	          v:
	            [d1: {z: [m: posnat, {n: posnat | m /= n}] | z`1 + z`2 < m + n} ->
	               {ret: [nat, nat] |
	                  gcd_rem(d1`1, d1`2) = ret`1 * d1`1 - ret`2 * d1`2}]):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND NOT m > n IMPLIES
	     FORALL (k1: nat): k1 = v(m, nmod(n, m))`1 IMPLIES m + nmod(n, m) < m + n
	
	% Subtype TCC generated (at line 49, column 6) for
	% (k1 + div(n, m) * k2, k2)
	% expected type  {ret: [nat, nat] |
	%    gcd_rem(m, n) = ret`1 * m - ret`2 * n}
	  % proved
	linear_comb_TCC16: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n,
	          v:
	            [d1: {z: [m: posnat, {n: posnat | m /= n}] | z`1 + z`2 < m + n} ->
	               {ret: [nat, nat] |
	                  gcd_rem(d1`1, d1`2) = ret`1 * d1`1 - ret`2 * d1`2}]):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND NOT m > n IMPLIES
	     FORALL (k1: nat, k2: nat):
	       k1 = v(m, nmod(n, m))`1 AND k2 = v(m, nmod(n, m))`2 IMPLIES
	        gcd_rem(m, n) = (k1 + div(n, m) * k2) * m - k2 * n
	
	% Subtype TCC generated (at line 47, column 30) for  nmod(n, m)
	% expected type  {n: posnat | m /= n}
	  % proved
	linear_comb_TCC17: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND NOT m > n IMPLIES
	     nmod(n, m) > 0 AND m /= nmod(n, m)
	
	% Termination TCC generated (at line 47, column 16) for
	% linear_comb(m, nmod(n, m))
	  % proved
	linear_comb_TCC18: OBLIGATION
	FORALL (m: posnat, n: posnat | m /= n):
	    NOT nmod(m, n) = 0 AND NOT nmod(n, m) = 0 AND NOT m > n IMPLIES
	     m + nmod(n, m) < m + n
	
	% The subtype TCC (at line 58, column 12) in decl nil for
	 % term generated from gcd_rem_linear_comb  n
	    % expected type  {n: int | NOT abs(m) + abs(n) = 0}
	  % is subsumed by linear_comb_TCC1

END gcd_rem_TCCS