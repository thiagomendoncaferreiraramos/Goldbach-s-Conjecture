%%
% @theory: Goldbach
% @author: thiago
% @date: Thu, 12 Dec 2024 18:16:15 GMT
%%
Goldbach: THEORY
  BEGIN 
    IMPORTING gcd_rem,
              ints@primes,
              %ints@div_nat,
              structures@set_as_list_props[nat]

    %List of primes less than or equal then n.
    list_of_primes(n : nat): RECURSIVE list[(prime?)] =
    IF n < 2 THEN (::)
    ELSIF prime?(n) THEN cons(n,list_of_primes(n-1))
    ELSE list_of_primes(n-1)
    ENDIF
    MEASURE n


    % @QED list_of_primes_correctness proved by thiago on Wed, 19 Feb 2025 00:20:26 GMT
    list_of_primes_correctness: LEMMA
    FORALL(n : nat, i : below[length(list_of_primes(n))]):
    prime?(nth(list_of_primes(n),i)) AND nth(list_of_primes(n),i) <= n

    list_prod(l : list[nat]) : RECURSIVE nat =
    IF null?(l) THEN 1
    ELSE car(l) * list_prod(cdr(l))
    ENDIF
    MEASURE length(l)

    % @QED list_prod_greater0 proved by thiago on Mon, 01 Dec 2025 20:34:13 GMT
    list_prod_greater0 : LEMMA
    FORALL(l : list[nat]) :
    (FORALL(i : below[length(l)]) : nth(l,i) > 0) IMPLIES list_prod(l) > 0

    list_prod_l2(l : list[above[2]]) : RECURSIVE nat =
    IF null?(l) THEN 1
    ELSE (car(l) - 2) * list_prod_l2(cdr(l))
    ENDIF
    MEASURE length(l)

    %prod_leq_n(n : posnat, i : below[n]) : RECURSIVE list[nat] =
    %IF list_prod(list_of_primes(i)) <= n THEN
    %  list_of_primes(i)
    %ELSE prod_leq_n(n , i - 1)
    %ENDIF
    %MEASURE i

    
    list_sieve_aux(m : nat, p : (prime?), r : below[m+1]) : RECURSIVE list[nat] =
    IF r + p > m THEN (: r :)
    ELSE cons(r, list_sieve_aux(m, p , r + p))
    ENDIF
    MEASURE m - r

   % @QED member_list_sieve_aux proved by thiago on Mon, 24 Nov 2025 22:06:07 GMT
   member_list_sieve_aux: LEMMA
   FORALL(m : nat, p : (prime?), r : below[m+1], k : nat) :
   member( k , list_sieve_aux(m, p, r)) =>
   k >= r

   % @QED card_sl_list_sieve_aux proved by thiago on Thu, 27 Nov 2025 22:04:13 GMT
   card_sl_list_sieve_aux: LEMMA
   FORALL(m : nat, p : (prime?), r : below[m+1]) :
   card_sl(list_sieve_aux(m, p, r)) =
   div(m-r, p) + 1

    list_sieve(m : nat, p : (prime?), r : below[p] | r < m+1) : list[nat] =
    list_sieve_aux(m, p, r)

    list_sieve0(m : nat, p : (prime?), r : below[p] | r < m+1) : list[nat] =
    union_sl(list_sieve_aux(m, p, 0), list_sieve(m, p, r))

  % @QED list_sieve_member proved by thiago on Sat, 06 Dec 2025 00:17:15 GMT
  list_sieve_member : LEMMA
  FORALL(m : nat, p : (prime?), r2 : below[m+1], r1 : nat) :
  member(r1, list_sieve_aux(m,p,r2)) IMPLIES
      divides(p,r1-r2)

   % @QED list_sieve_disjoint proved by thiago on Sat, 06 Dec 2025 00:47:51 GMT
   list_sieve_disjoint : LEMMA
   FORALL(m : nat, p : (prime?), r1, r2 : below[m+1]) :
      NOT divides(p,abs(r1-r2)) IMPLIES
      disjoint_sl?(list_sieve_aux(m, p, r1), list_sieve_aux(m, p, r2))

   list_less(n : nat) : RECURSIVE list[nat] =
    IF n = 0 THEN (: 0 :)
    ELSE cons(n,list_less(n-1))
    ENDIF
    MEASURE n

    % @QED list_less_member proved by thiago on Sat, 22 Nov 2025 20:34:09 GMT
    list_less_member: LEMMA
    FORALL(n : nat, k : nat) :
    member(k, list_less(n))  IFF k <= n

   % @QED card_sl_list_less proved by thiago on Sat, 22 Nov 2025 20:45:35 GMT
   card_sl_list_less: LEMMA
   FORALL(n : nat) : card_sl(list_less(n)) = n + 1

  % @QED list_less_correctness proved by thiago on Sat, 06 Dec 2025 01:26:28 GMT
  list_less_correctness: LEMMA
  FORALL(n : nat, k : below[n+1]):
  member(k, list_less(n))

  % @QED subset_sl_list_sieve_aux proved by thiago on Sat, 06 Dec 2025 01:31:31 GMT
  subset_sl_list_sieve_aux: LEMMA
    FORALL(m : nat, p : (prime?), r : below[m+1]) :
   subset_sl?(list_sieve_aux(m, p , r),list_less(m))

    signature_pred(pl : list[posnat], m : nat)(l : list[nat] 
          | length(l) = length(pl)) : bool =
    FORALL(i : below[length(l)]):
    nth(l,i) < nth(pl,i)
    AND nth(l, i) < m


    sieve_union(m : nat, pl : (cons?[(prime?)]), rl : (signature_pred(pl,m)) ):
    RECURSIVE list[nat] =
      IF length(pl) = 1 THEN list_sieve0(m, car(pl), car(rl))
      ELSE union_sl(list_sieve0(m, car(pl),car(rl)), sieve_union(m,cdr(pl),cdr(rl)))
      ENDIF
      MEASURE length(pl)

    sieve_union_lemma : CONJECTURE
    FORALL (m : nat, pl : (cons?[(prime?)]) , rl : (signature_pred(pl,m))) :
    (FORALL(i : below[length(pl)]) : nth(pl,i) > 2) IMPLIES
    card_sl(difference_sl(list_less(m),sieve_union(m,pl,rl))) >= 
    m * list_prod_l2(pl)/list_prod(pl) - 1
   

    sign_aux(n : nat)(l : list[posnat]) : RECURSIVE list[nat] =
    CASES l OF
        null : null,
        cons(h,t) : cons(nmod(n,h), sign_aux(n)(t))
    ENDCASES
    MEASURE length(l)

    mut_primes(primes_l : list[posnat]) : bool =
    FORALL(i , j : below[length(primes_l)]) :
    i /= j IMPLIES 
    gcd_rem(nth(primes_l,i), nth(primes_l,j)) = 1

    nmod_pos(n : int, p : posnat): mod(p) =
    IF n >= 0 THEN nmod(n, p)
    ELSE p - nmod(-n, p)
    ENDIF

    diff(x,y : nat) : nat =
    IF x = 0 AND y = 0 THEN 1
    ELSIF (x = 0 AND y = 1) OR
          (x = 1 AND y = 0) THEN 2
    ELSE 0
    ENDIF

    diff_build(p1 : (prime?), p2 : (prime?) | p1 /= p2)
                (e1 : below[p1], e2 : below[p2]) : below[p2] =
    nmod(linear_comb(p1,p2)`2 * nmod_pos(e2 - e1, p2), p2)


    %list-diff-pred(l : list[posnat])

    

    %tuple_buid_list(l : list[nat])(list_t : list[[nat,nat]]) : list[[nat,nat]] =
    

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % sign2nats(primes_l : (cons?[posnat]) | mut_primes(primes_l))
   %          (signs : (signature_pred(primes_l))) :
   % RECURSIVE [nat,nat] =
   % IF length(primes_l) = 1 THEN (car(primes_l), car(signs))
   % ELSE 
   %       LET tuple = sign2nats(cdr(primes_l))(cdr(signs)),
   %       prod = tuple`1,
   %       val  = tuple`2,
   %       prod_inv = linear_comb(prod, car(primes_l))`1 IN
   %  (prod * car(primes_l), prod * nmod(prod_inv * 
   %                                   (nmod_pos( car(signs) - val, car(primes_l))),car(primes_l)) 
   %                         + val)
   % ENDIF
   % MEASURE length(primes_l)

    list_diff(p : nat)(n : nat) : RECURSIVE list[nat] =
    IF p = 0 THEN (::)
    ELSIF p = n THEN list_diff(p-1)(n)
    ELSE cons(p, list_diff(p-1)(n))
    ENDIF
    MEASURE p

    list_less(k : posnat) : RECURSIVE list[posnat] =
    IF k = 1 THEN (:1:)
    ELSE append(list_less(k-1),(:k:))
    ENDIF
    MEASURE k

    list_l_diff(primes_l : list[posnat])
               (signs : list[nat] | length(signs) = length(primes_l)):
    RECURSIVE list[list[nat]] =
    IF null?(primes_l) THEN (::)
    ELSE cons(list_diff(car(primes_l))(car(signs)), list_l_diff(cdr(primes_l))(cdr(signs)))
    ENDIF
    MEASURE length(primes_l)

    e_list(n : nat, l : list[list[nat]]) : RECURSIVE list[list[nat]] =
    IF null?(l) THEN (::)
    ELSE cons(cons(n, car(l)), e_list(n,cdr(l)))
    ENDIF
    MEASURE length(l)



    %cart_list(l1 : list[nat], llnat : list[list[nat]]) : RECURSIVE list[list[nat]] =
    %IF null?(l1) THEN (: (::) :)
    %ELSE append(e_list(car(l1),llnat), cart_list(cdr(l1),llnat))
    %ENDIF
    %MEASURE length(l1)

    list2onelist(l1 : list[nat]) : RECURSIVE list[list[nat]] =
    IF null?(l1) THEN (::)
    ELSE cons((: car(l1) :), list2onelist(cdr(l1)))
    ENDIF
    MEASURE length(l1)

    %cart_Lists(llnat : (cons?[list[nat]])) : RECURSIVE list[list[nat]] =
    %IF length(llnat) = 1 THEN list2onelist(car(llnat))
    %ELSE cart_list(car(llnat), cart_Lists(cdr(llnat)))
    %ENDIF
    %MEASURE length(llnat)

    % @QED sign_aux_length proved by thiago on Thu, 27 Feb 2025 00:38:17 GMT
    sign_aux_length: LEMMA
    FORALL(n : nat, l : list[posnat]):
    length(sign_aux(n)(l)) = length(l)
    
    % @QED sign_aux_correctness proved by thiago on Thu, 27 Feb 2025 00:45:27 GMT
    sign_aux_correctness : LEMMA
    FORALL(n : nat, l :list[posnat], i : below[length(l)]):
    nth(sign_aux(n)(l),i) < nth(l,i)

   
   % Goldbach_list_signs( n : posnat) : list[list[nat]] =
   % cart_Lists(list_l_diff(prod_leq_n(2*n,2*n-1))((sign_aux(2*n)(prod_leq_n(2*n,2*n-1)))))
    
   % Goldbach_list(n : posnat) : list[nat] =
   % map(lambda(m,n : nat) :  n ) (map (sign2nats(prod_leq_n(2*n,2*n-1)))(Goldbach_list_signs(n)))


    IMPORTING Bin_tree[list[nat]]

    list_Bin_Tree(l : list[nat], Bt : Bin_tree, f : [list[nat]->list[nat]]) : bool =
    CASES Bt OF
          Empty : TRUE,
          Bin_T(lbt,Bt_left,Bt_right) : f(l) = lbt
    ENDCASES

    


    l_prime(p : (prime?) | p /= 2)(n : below[p]) : below[p] =
    IF even?(n) THEN n / 2
    ELSE (p + n) / 2
    ENDIF

    r_prime(p : (prime?) | p /= 2)(n : below[p]) : below[p] =
    IF odd?(n) THEN (n - 1 ) / 2
    ELSE (p + n - 1) / 2
    ENDIF

    mapl_prime(p : (prime?) | p /= 2)(l : list[below[p]]) : list[below[p]] =
    map(l_prime(p))(l)

    mapr_prime(p : (prime?) | p /= 2)(l : list[below[p]]) : list[below[p]] =
    map(r_prime(p))(l)

    Bin_tree_build(p : (prime?) | p /= 2)
                  (depth : nat, l : list[below[p]]) : RECURSIVE Bin_tree =
    IF depth = 0 THEN Bin_T(l, Empty, Empty)
    ELSE Bin_T(l, Bin_tree_build(p)(depth-1, mapl_prime(p)(l)),
                  Bin_tree_build(p)(depth-1, mapr_prime(p)(l)))
    ENDIF
    MEASURE depth

    

    %list_tree_1 : CONJECTURE
    
    
    %list_sum_split(i, n : nat) : RECURSIVE list[list[nat]] =
    %IF i = 0 THEN list_sum(n)
    %ELSE LET lss = list_sum_split(i-1,n) IN
    

    Goldbach : CHALLENGE
    FORALL(n : nat | n >= 2):
    EXISTS(p1, p2 : (prime?)):
    2*n = p1 + p2

    
  END Goldbach
