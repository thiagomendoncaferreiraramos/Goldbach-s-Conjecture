%%
% @theory: Goldbach
% @author: thiago
% @date: Thu, 12 Dec 2024 18:16:15 GMT
%%
Goldbach: THEORY
  BEGIN 
    IMPORTING gcd_rem,
              ints@primes

    %List of primes less than or equal then n.
    list_of_primes(n : nat): RECURSIVE list[(prime?)] =
    IF n < 2 THEN (::)
    ELSIF prime?(n) THEN append(list_of_primes(n-1),(:n:))
    ELSE list_of_primes(n-1)
    ENDIF
    MEASURE n


    % @QED list_of_primes_correctness proved by thiago on Wed, 19 Feb 2025 00:20:26 GMT
    list_of_primes_correctness: LEMMA
    FORALL(n : nat, i : below[length(list_of_primes(n))]):
    prime?(nth(list_of_primes(n),i)) AND nth(list_of_primes(n),i) <= n

    list_prod(l : list[nat]) : RECURSIVE nat =
    IF null?(l) THEN 1
    ELSE car(l) * list_prod(cdr(l))
    ENDIF
    MEASURE length(l)

    prod_leq_n(n : posnat, i : below[n]) : RECURSIVE list[nat] =
    IF list_prod(list_of_primes(i)) <= n THEN
      list_of_primes(i)
    ELSE prod_leq_n(n , i - 1)
    ENDIF
    MEASURE i

  

    signature_pred(pl : list[posnat])(l : list[nat] 
          | length(l) = length(pl)) : bool =
    FORALL(i : below[length(l)]):
    nth(l,i) < nth(pl,i)

    sign_aux(n : nat)(l : list[posnat]) : RECURSIVE list[nat] =
    CASES l OF
        null : null,
        cons(h,t) : cons(nmod(n,h), sign_aux(n)(t))
    ENDCASES
    MEASURE length(l)

    mut_primes(primes_l : list[posnat]) : bool =
    FORALL(i , j : below[length(primes_l)]) :
    i /= j IMPLIES 
    gcd_rem(nth(primes_l,i), nth(primes_l,j)) = 1

    nmod_pos(n : int, p : posnat): mod(p) =
    IF n >= 0 THEN nmod(n, p)
    ELSE p - nmod(-n, p)
    ENDIF

    sign2nats(primes_l : (cons?[posnat]) | mut_primes(primes_l))
             (signs : (signature_pred(primes_l))) :
    RECURSIVE [nat,nat] =
    IF length(primes_l) = 1 THEN (car(primes_l), car(signs))
    ELSE 
          LET tuple = sign2nats(cdr(primes_l))(cdr(signs)),
          prod = tuple`1,
          val  = tuple`2,
          prod_inv = linear_comb(prod, car(primes_l))`1 IN
     (prod * car(primes_l), prod * nmod(prod_inv * 
                                      (nmod_pos( car(signs) - val, car(primes_l))),car(primes_l)) 
                            + val)
    ENDIF
    MEASURE length(primes_l)

    list_diff(p : nat)(n : nat) : RECURSIVE list[nat] =
    IF p = 0 THEN (::)
    ELSIF p = n THEN list_diff(p-1)(n)
    ELSE cons(p, list_diff(p-1)(n))
    ENDIF
    MEASURE p

    list_l_diff(primes_l : list[posnat])
               (signs : list[nat] | length(signs) = length(primes_l)):
    RECURSIVE list[list[nat]] =
    IF null?(primes_l) THEN (::)
    ELSE cons(list_diff(car(primes_l))(car(signs)), list_l_diff(cdr(primes_l))(cdr(signs)))
    ENDIF
    MEASURE length(primes_l)

    e_list(n : nat, l : list[list[nat]]) : RECURSIVE list[list[nat]] =
    IF null?(l) THEN (::)
    ELSE cons(cons(n, car(l)), e_list(n,cdr(l)))
    ENDIF
    MEASURE length(l)



    cart_list(l1 : list[nat], llnat : list[list[nat]]) : RECURSIVE list[list[nat]] =
    IF null?(l1) THEN (: (::) :)
    ELSE append(e_list(car(l1),llnat), cart_list(cdr(l1),llnat))
    ENDIF
    MEASURE length(l1)

    list2onelist(l1 : list[nat]) : RECURSIVE list[list[nat]] =
    IF null?(l1) THEN (::)
    ELSE cons((: car(l1) :), list2onelist(cdr(l1)))
    ENDIF
    MEASURE length(l1)

    cart_Lists(llnat : (cons?[list[nat]])) : RECURSIVE list[list[nat]] =
    IF length(llnat) = 1 THEN list2onelist(car(llnat))
    ELSE cart_list(car(llnat), cart_Lists(cdr(llnat)))
    ENDIF
    MEASURE length(llnat)

    % @QED sign_aux_length proved by thiago on Thu, 27 Feb 2025 00:38:17 GMT
    sign_aux_length: LEMMA
    FORALL(n : nat, l : list[posnat]):
    length(sign_aux(n)(l)) = length(l)
    
    % @QED sign_aux_correctness proved by thiago on Thu, 27 Feb 2025 00:45:27 GMT
    sign_aux_correctness : LEMMA
    FORALL(n : nat, l :list[posnat], i : below[length(l)]):
    nth(sign_aux(n)(l),i) < nth(l,i)

   
    Goldbach_list_signs( n : posnat) : list[list[nat]] =
    cart_Lists(list_l_diff(prod_leq_n(2*n,2*n-1))((sign_aux(2*n)(prod_leq_n(2*n,2*n-1)))))
    
    Goldbach_list(n : posnat) : list[nat] =
    map(lambda(m,n : nat) :  n ) (map (sign2nats(prod_leq_n(2*n,2*n-1)))(Goldbach_list_signs(n)))



    kappa(n : nat)(x : below[n+1] ,y : below[x+1]) : nat =
    y + ((n+x+2)*(n-x+1))/2

    kappa_(n : nat)(x : below[n+1] ,y : below[x+1]) : RECURSIVE nat =
    IF x = n THEN y
    ELSIF y = 0 THEN 1 + kappa_(n)(x+1,x+1)
    ELSE 1 + kappa_(n)(x,y-1)
    ENDIF
    MEASURE kappa(n)(x,y) 

    %kappa_inv(n : nat)(i : nat) : RECURSIVE [nat,nat] =


    Goldbach : CHALLENGE
    FORALL(n : nat | n >= 2):
    EXISTS(p1, p2 : (prime?)):
    2*n = p1 + p2

    
  END Goldbach
